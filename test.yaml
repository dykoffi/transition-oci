eCOMPUTED VALUES:
affinity: {}
airflow:
  affinity: {}
  airflowConfigAnnotations: {}
  airflowHome: /opt/airflow
  airflowLocalSettings: |-
    {{- if semverCompare ">=2.2.0" .Values.airflowVersion }}
    {{- if not (or .Values.webserverSecretKey .Values.webserverSecretKeySecretName) }}
    from airflow.www.utils import UIAlert

    DASHBOARD_UIALERTS = [
      UIAlert(
        'Usage of a dynamic webserver secret key detected. We recommend a static webserver secret key instead.'
        ' See the <a href='
        '"https://airflow.apache.org/docs/helm-chart/stable/production-guide.html#webserver-secret-key">'
        'Helm Chart Production Guide</a> for more details.',
        category="warning",
        roles=["Admin"],
        html=True,
      )
    ]
    {{- end }}
    {{- end }}
  airflowPodAnnotations: {}
  airflowVersion: 2.4.1
  allowPodLaunching: true
  cleanup:
    affinity: {}
    args:
    - bash
    - -c
    - exec airflow kubernetes cleanup-pods --namespace={{ .Release.Namespace }}
    enabled: false
    env: []
    labels: {}
    nodeSelector: {}
    podAnnotations: {}
    resources: {}
    schedule: '*/15 * * * *'
    securityContext: {}
    serviceAccount:
      annotations: {}
      create: true
    tolerations: []
    topologySpreadConstraints: []
  config:
    celery:
      flower_url_prefix: '{{ .Values.ingress.flower.path }}'
      worker_concurrency: 16
    celery_kubernetes_executor:
      kubernetes_queue: kubernetes
    core:
      colored_console_log: "False"
      dags_folder: '{{ include "airflow_dags" . }}'
      executor: '{{ .Values.executor }}'
      load_examples: "False"
      remote_logging: '{{- ternary "True" "False" .Values.elasticsearch.enabled }}'
    elasticsearch:
      json_format: "True"
      log_id_template: '{dag_id}_{task_id}_{execution_date}_{try_number}'
      write_stdout: "True"
    elasticsearch_configs:
      max_retries: 3
      retry_timeout: "True"
      timeout: 30
    kerberos:
      ccache: '{{ .Values.kerberos.ccacheMountPath }}/{{ .Values.kerberos.ccacheFileName
        }}'
      keytab: '{{ .Values.kerberos.keytabPath }}'
      principal: '{{ .Values.kerberos.principal }}'
      reinit_frequency: '{{ .Values.kerberos.reinitFrequency }}'
    kubernetes:
      airflow_configmap: '{{ include "airflow_config" . }}'
      airflow_local_settings_configmap: '{{ include "airflow_config" . }}'
      multi_namespace_mode: '{{ ternary "True" "False" .Values.multiNamespaceMode
        }}'
      namespace: '{{ .Release.Namespace }}'
      pod_template_file: '{{ include "airflow_pod_template_file" . }}/pod_template_file.yaml'
      worker_container_repository: '{{ .Values.images.airflow.repository | default
        .Values.defaultAirflowRepository }}'
      worker_container_tag: '{{ .Values.images.airflow.tag | default .Values.defaultAirflowTag
        }}'
    logging:
      colored_console_log: "False"
      remote_logging: '{{- ternary "True" "False" .Values.elasticsearch.enabled }}'
    metrics:
      statsd_host: '{{ printf "%s-statsd" .Release.Name }}'
      statsd_on: '{{ ternary "True" "False" .Values.statsd.enabled }}'
      statsd_port: 9125
      statsd_prefix: airflow
    scheduler:
      run_duration: 41460
      standalone_dag_processor: '{{ ternary "True" "False" .Values.dagProcessor.enabled
        }}'
      statsd_host: '{{ printf "%s-statsd" .Release.Name }}'
      statsd_on: '{{ ternary "True" "False" .Values.statsd.enabled }}'
      statsd_port: 9125
      statsd_prefix: airflow
    webserver:
      enable_proxy_fix: "True"
      rbac: "True"
  createUserJob:
    affinity: {}
    annotations: {}
    args:
    - bash
    - -c
    - |-
      exec \
      airflow {{ semverCompare ">=2.0.0" .Values.airflowVersion | ternary "users create" "create_user" }} "$@"
    - --
    - -r
    - '{{ .Values.webserver.defaultUser.role }}'
    - -u
    - '{{ .Values.webserver.defaultUser.username }}'
    - -e
    - '{{ .Values.webserver.defaultUser.email }}'
    - -f
    - '{{ .Values.webserver.defaultUser.firstName }}'
    - -l
    - '{{ .Values.webserver.defaultUser.lastName }}'
    - -p
    - '{{ .Values.webserver.defaultUser.password }}'
    env: []
    extraContainers: []
    extraVolumeMounts: []
    extraVolumes: []
    jobAnnotations: {}
    labels: {}
    nodeSelector: {}
    resources: {}
    securityContext: {}
    serviceAccount:
      annotations: {}
      create: true
    tolerations: []
    topologySpreadConstraints: []
    useHelmHooks: true
  dagProcessor:
    affinity: {}
    args:
    - bash
    - -c
    - exec airflow dag-processor
    enabled: false
    env: []
    extraContainers: []
    extraInitContainers: []
    extraVolumeMounts: []
    extraVolumes: []
    livenessProbe:
      failureThreshold: 5
      initialDelaySeconds: 10
      periodSeconds: 60
      timeoutSeconds: 20
    nodeSelector: {}
    podAnnotations: {}
    replicas: 1
    resources: {}
    safeToEvict: true
    securityContext: {}
    serviceAccount:
      annotations: {}
      create: true
    strategy:
      rollingUpdate:
        maxSurge: 100%
        maxUnavailable: 50%
    terminationGracePeriodSeconds: 60
    tolerations: []
    topologySpreadConstraints: []
    waitForMigrations:
      enabled: true
      env: []
  dags:
    gitSync:
      branch: dev
      containerName: git-sync
      
      depth: 1
      enabled: true
      env:
      - name: http_proxy
        value: http://192.168.42.15:3128
      - name: https_proxy
        value: http://192.168.42.15:3128
      extraVolumeMounts: []
      maxFailures: 0
      repo: https://github.com/data354/OCI-JOBS.git
      resources: {}
      rev: HEAD
      securityContext: {}
      sshKeySecret: null
      subPath: dags
      uid: 65533
      wait: 60
    persistence:
      accessMode: ReadWriteOnce
      enabled: false
      size: 5Gi
  data:
    metadataConnection:
      db: postgres
      pass: postgres
      port: 5432
      protocol: postgresql
      sslmode: disable
      user: postgres
  defaultAirflowRepository: apache/airflow
  defaultAirflowTag: 2.4.1
  elasticsearch:
    connection:
      host: loki.default
      port: 3100
    enabled: false
  enableBuiltInSecretEnvVars:
    AIRFLOW__CELERY__BROKER_URL: true
    AIRFLOW__CELERY__CELERY_RESULT_BACKEND: true
    AIRFLOW__CELERY__RESULT_BACKEND: true
    AIRFLOW__CORE__FERNET_KEY: true
    AIRFLOW__CORE__SQL_ALCHEMY_CONN: true
    AIRFLOW__DATABASE__SQL_ALCHEMY_CONN: true
    AIRFLOW__ELASTICSEARCH__ELASTICSEARCH_HOST: true
    AIRFLOW__ELASTICSEARCH__HOST: true
    AIRFLOW__WEBSERVER__SECRET_KEY: true
    AIRFLOW_CONN_AIRFLOW_DB: true
  enabled: true
  env: []
  executor: CeleryExecutor
  extraConfigMaps: {}
  extraSecrets: {}
  flower:
    affinity: {}
    args:
    - bash
    - -c
    - |-
      exec \
      airflow {{ semverCompare ">=2.0.0" .Values.airflowVersion | ternary "celery flower" "flower" }}
    enabled: false
    env: []
    extraContainers: []
    extraNetworkPolicies: []
    extraVolumeMounts: []
    extraVolumes: []
    labels: {}
    networkPolicy:
      ingress:
        from: []
        ports:
        - port: '{{ .Values.ports.flowerUI }}'
    nodeSelector: {}
    podAnnotations: {}
    resources: {}
    securityContext: {}
    service:
      annotations: {}
      loadBalancerSourceRanges: []
      ports:
      - name: flower-ui
        port: '{{ .Values.ports.flowerUI }}'
      type: ClusterIP
    serviceAccount:
      annotations: {}
      create: true
    tolerations: []
    topologySpreadConstraints: []
  fullnameOverride: ""
  gid: 0
  git:
    connexionType: http
    login: yasmine-datalab
    password: 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
  global: {}
  images:
    airflow:
      pullPolicy: IfNotPresent
      repository: team354/airflow-gps
      tag: 1.4.0
    flower:
      pullPolicy: IfNotPresent
    gitSync:
      pullPolicy: IfNotPresent
      repository: k8s.gcr.io/git-sync/git-sync
      tag: v3.4.0
    migrationsWaitTimeout: 120
    pgbouncer:
      pullPolicy: IfNotPresent
      repository: apache/airflow
      tag: airflow-pgbouncer-2021.04.28-1.14.0
    pgbouncerExporter:
      pullPolicy: IfNotPresent
      repository: apache/airflow
      tag: airflow-pgbouncer-exporter-2021.09.22-0.12.0
    pod_template:
      pullPolicy: IfNotPresent
    redis:
      pullPolicy: IfNotPresent
      repository: redis
      tag: 6-bullseye
    statsd:
      pullPolicy: IfNotPresent
      repository: quay.io/prometheus/statsd-exporter
      tag: v0.22.8
    useDefaultImageForMigration: false
  ingress:
    flower:
      annotations: {}
      enabled: false
      host: ""
      hosts: []
      ingressClassName: ""
      path: /
      pathType: ImplementationSpecific
      tls:
        enabled: false
        secretName: ""
    web:
      annotations: {}
      enabled: false
      host: ""
      hosts: []
      ingressClassName: ""
      path: /
      pathType: ImplementationSpecific
      precedingPaths: []
      succeedingPaths: []
      tls:
        enabled: false
        secretName: ""
  kerberos:
    ccacheFileName: cache
    ccacheMountPath: /var/kerberos-ccache
    config: |
      # This is an example config showing how you can use templating and how "example" config
      # might look like. It works with the test kerberos server that we are using during integration
      # testing at Apache Airflow (see `scripts/ci/docker-compose/integration-kerberos.yml` but in
      # order to make it production-ready you must replace it with your own configuration that
      # Matches your kerberos deployment. Administrators of your Kerberos instance should
      # provide the right configuration.

      [logging]
      default = "FILE:{{ template "airflow_logs_no_quote" . }}/kerberos_libs.log"
      kdc = "FILE:{{ template "airflow_logs_no_quote" . }}/kerberos_kdc.log"
      admin_server = "FILE:{{ template "airflow_logs_no_quote" . }}/kadmind.log"

      [libdefaults]
      default_realm = FOO.COM
      ticket_lifetime = 10h
      renew_lifetime = 7d
      forwardable = true

      [realms]
      FOO.COM = {
        kdc = kdc-server.foo.com
        admin_server = admin_server.foo.com
      }
    configPath: /etc/krb5.conf
    enabled: false
    keytabPath: /etc/airflow.keytab
    principal: airflow@FOO.COM
    reinitFrequency: 3600
  kubeVersionOverride: ""
  labels: {}
  limits: []
  logs:
    persistence:
      enabled: false
      size: 100Gi
  migrateDatabaseJob:
    affinity: {}
    annotations: {}
    args:
    - bash
    - -c
    - |-
      exec \
      airflow {{ semverCompare ">=2.0.0" .Values.airflowVersion | ternary "db upgrade" "upgradedb" }}
    enabled: true
    extraContainers: []
    extraVolumeMounts: []
    extraVolumes: []
    jobAnnotations: {}
    nodeSelector: {}
    resources: {}
    securityContext: {}
    serviceAccount:
      annotations: {}
      create: true
    tolerations: []
    topologySpreadConstraints: []
    useHelmHooks: true
  multiNamespaceMode: false
  nameOverride: ""
  networkPolicies:
    enabled: false
  nodeSelector: {}
  pgbouncer:
    affinity: {}
    auth_file: /etc/pgbouncer/users.txt
    auth_type: md5
    ciphers: normal
    command:
    - pgbouncer
    - -u
    - nobody
    - /etc/pgbouncer/pgbouncer.ini
    enabled: false
    extraNetworkPolicies: []
    extraVolumeMounts: []
    extraVolumes: []
    logConnections: 0
    logDisconnections: 0
    maxClientConn: 100
    metadataPoolSize: 10
    metricsExporterSidecar:
      resources: {}
      sslmode: disable
    nodeSelector: {}
    podDisruptionBudget:
      config:
        maxUnavailable: 1
      enabled: false
    resources: {}
    resultBackendPoolSize: 5
    service:
      extraAnnotations: {}
    serviceAccount:
      annotations: {}
      create: true
    ssl: {}
    sslmode: prefer
    tolerations: []
    topologySpreadConstraints: []
    uid: 65534
    verbose: 0
  ports:
    airflowUI: 8080
    flowerUI: 5555
    pgbouncer: 6543
    pgbouncerScrape: 9127
    redisDB: 6379
    statsdIngest: 9125
    statsdScrape: 9102
    workerLogs: 8793
  postgresql:
    audit:
      clientMinMessages: error
      logConnections: false
      logDisconnections: false
      logHostname: false
      logLinePrefix: ""
      logTimezone: ""
      pgAuditLog: ""
      pgAuditLogCatalog: "off"
    common:
      exampleValue: common-chart
      global:
        imagePullSecrets: []
        postgresql: {}
    commonAnnotations: {}
    containerSecurityContext:
      enabled: true
      runAsUser: 1001
    customLivenessProbe: {}
    customReadinessProbe: {}
    customStartupProbe: {}
    enabled: true
    extraDeploy: []
    extraEnv: []
    global:
      imagePullSecrets: []
      postgresql:
        existingSecret: null
        postgresqlDatabase: null
        postgresqlPassword: null
        postgresqlUsername: null
        replicationPassword: null
        servicePort: null
    image:
      debug: false
      pullPolicy: IfNotPresent
      pullSecrets: []
      registry: docker.io
      repository: bitnami/postgresql
      tag: 11.12.0-debian-10-r44
    initdbScripts: {}
    ldap:
      baseDN: ""
      bind_password: null
      bindDN: ""
      enabled: false
      port: ""
      prefix: ""
      scheme: ""
      search_attr: ""
      search_filter: ""
      server: ""
      suffix: ""
      tls: {}
      url: ""
    livenessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 30
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    metrics:
      customMetrics: {}
      enabled: false
      extraEnvVars: {}
      image:
        pullPolicy: IfNotPresent
        pullSecrets: []
        registry: docker.io
        repository: bitnami/postgres-exporter
        tag: 0.9.0-debian-10-r108
      livenessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 5
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      prometheusRule:
        additionalLabels: {}
        enabled: false
        namespace: ""
        rules: []
      readinessProbe:
        enabled: true
        failureThreshold: 6
        initialDelaySeconds: 5
        periodSeconds: 10
        successThreshold: 1
        timeoutSeconds: 5
      resources: {}
      securityContext:
        enabled: false
        runAsUser: 1001
      service:
        annotations:
          prometheus.io/port: "9187"
          prometheus.io/scrape: "true"
        loadBalancerIP: null
        type: ClusterIP
      serviceMonitor:
        additionalLabels: {}
        enabled: false
        interval: null
        namespace: null
        scrapeTimeout: null
    networkPolicy:
      allowExternal: true
      enabled: false
      explicitNamespacesSelector: {}
    persistence:
      accessModes:
      - ReadWriteOnce
      annotations: {}
      enabled: true
      existingClaim: null
      mountPath: /bitnami/postgresql
      selector: {}
      size: 8Gi
      storageClass: null
      subPath: ""
    pgHbaConfiguration: ""
    postgresqlDataDir: /bitnami/postgresql/data
    postgresqlPassword: postgres
    postgresqlSharedPreloadLibraries: pgaudit
    postgresqlUsername: postgres
    primary:
      affinity: {}
      annotations: {}
      extraInitContainers: []
      extraVolumeMounts: []
      extraVolumes: []
      labels: {}
      nodeAffinityPreset:
        key: ""
        type: ""
        values: []
      nodeSelector: {}
      podAffinityPreset: ""
      podAnnotations: {}
      podAntiAffinityPreset: soft
      podLabels: {}
      priorityClassName: ""
      service:
        clusterIP: null
        nodePort: null
        type: null
      sidecars: []
      tolerations: []
    primaryAsStandBy:
      enabled: false
      primaryHost: null
      primaryPort: null
    psp:
      create: false
    rbac:
      create: false
    readReplicas:
      affinity: {}
      annotations: {}
      extraInitContainers: []
      extraVolumeMounts: []
      extraVolumes: []
      labels: {}
      nodeAffinityPreset:
        key: ""
        type: ""
        values: []
      nodeSelector: {}
      persistence:
        enabled: true
      podAffinityPreset: ""
      podAnnotations: {}
      podAntiAffinityPreset: soft
      podLabels: {}
      priorityClassName: ""
      resources: {}
      service:
        clusterIP: null
        nodePort: null
        type: null
      sidecars: []
      tolerations: []
    readinessProbe:
      enabled: true
      failureThreshold: 6
      initialDelaySeconds: 5
      periodSeconds: 10
      successThreshold: 1
      timeoutSeconds: 5
    replication:
      applicationName: my_application
      enabled: false
      numSynchronousReplicas: 0
      password: repl_password
      readReplicas: 1
      synchronousCommit: "off"
      user: repl_user
    resources:
      requests:
        cpu: 250m
        memory: 256Mi
    securityContext:
      enabled: true
      fsGroup: 1001
    service:
      annotations: {}
      clusterIP: null
      loadBalancerIP: null
      loadBalancerSourceRanges: []
      nodePort: null
      port: 5432
      type: ClusterIP
    serviceAccount:
      enabled: false
      name: null
    shmVolume:
      chmod:
        enabled: true
      enabled: true
      sizeLimit: null
    startupProbe:
      enabled: false
      failureThreshold: 10
      initialDelaySeconds: 30
      periodSeconds: 15
      successThreshold: 1
      timeoutSeconds: 5
    tls:
      autoGenerated: false
      certCAFilename: null
      certFilename: ""
      certKeyFilename: ""
      certificatesSecret: ""
      crlFilename: null
      enabled: false
      preferServerCiphers: true
    updateStrategy:
      type: RollingUpdate
    usePasswordFile: false
    volumePermissions:
      enabled: false
      image:
        pullPolicy: Always
        pullSecrets: []
        registry: docker.io
        repository: bitnami/bitnami-shell
        tag: 10-debian-10-r125
      securityContext:
        runAsUser: 0
  quotas: {}
  rbac:
    create: true
    createSCCRoleBinding: false
  redis:
    affinity: {}
    enabled: true
    nodeSelector: {}
    persistence:
      annotations: {}
      enabled: true
      size: 5Gi
    podAnnotations: {}
    resources: {}
    safeToEvict: true
    securityContext: {}
    serviceAccount:
      annotations: {}
      create: true
    terminationGracePeriodSeconds: 600
    tolerations: []
    topologySpreadConstraints: []
    uid: 0
  registry:
    connection: {}
  scheduler:
    affinity: {}
    args:
    - bash
    - -c
    - exec airflow scheduler
    env: []
    extraContainers: []
    extraInitContainers: []
    extraVolumeMounts: []
    extraVolumes: []
    labels: {}
    livenessProbe:
      failureThreshold: 5
      initialDelaySeconds: 10
      periodSeconds: 60
      timeoutSeconds: 20
    logGroomerSidecar:
      args:
      - bash
      - /clean-logs
      enabled: true
      resources: {}
      retentionDays: 15
    nodeSelector: {}
    podAnnotations: {}
    podDisruptionBudget:
      config:
        maxUnavailable: 1
      enabled: false
    replicas: 1
    resources: {}
    safeToEvict: true
    securityContext: {}
    serviceAccount:
      annotations: {}
      create: true
    tolerations: []
    topologySpreadConstraints: []
    waitForMigrations:
      enabled: true
      env: []
  secret: []
  securityContext: {}
  statsd:
    affinity: {}
    enabled: true
    extraMappings: []
    extraNetworkPolicies: []
    nodeSelector: {}
    overrideMappings: []
    podAnnotations: {}
    resources: {}
    securityContext: {}
    service:
      extraAnnotations: {}
    serviceAccount:
      annotations: {}
      create: true
    tolerations: []
    topologySpreadConstraints: []
    uid: 65534
  tolerations: []
  topologySpreadConstraints: []
  triggerer:
    affinity: {}
    args:
    - bash
    - -c
    - exec airflow triggerer
    enabled: true
    env: []
    extraContainers: []
    extraInitContainers: []
    extraVolumeMounts: []
    extraVolumes: []
    labels: {}
    livenessProbe:
      failureThreshold: 5
      initialDelaySeconds: 10
      periodSeconds: 60
      timeoutSeconds: 20
    nodeSelector: {}
    podAnnotations: {}
    replicas: 1
    resources: {}
    safeToEvict: true
    securityContext: {}
    serviceAccount:
      annotations: {}
      create: true
    strategy:
      rollingUpdate:
        maxSurge: 100%
        maxUnavailable: 50%
    terminationGracePeriodSeconds: 60
    tolerations: []
    topologySpreadConstraints: []
    waitForMigrations:
      enabled: true
      env: []
  uid: 50000
  webserver:
    affinity: {}
    allowPodLogReading: true
    args:
    - bash
    - -c
    - exec airflow webserver
    defaultUser:
      email: admin@example.com
      enabled: true
      firstName: admin
      lastName: user
      password: admin
      role: Admin
      username: admin
    env: []
    extraContainers: []
    extraInitContainers: []
    extraNetworkPolicies: []
    extraVolumeMounts: []
    extraVolumes: []
    labels: {}
    livenessProbe:
      failureThreshold: 20
      initialDelaySeconds: 15
      periodSeconds: 5
      scheme: HTTP
      timeoutSeconds: 30
    networkPolicy:
      ingress:
        from: []
        ports:
        - port: '{{ .Values.ports.airflowUI }}'
    nodeSelector: {}
    podAnnotations: {}
    podDisruptionBudget:
      config:
        maxUnavailable: 1
      enabled: false
    readinessProbe:
      failureThreshold: 20
      initialDelaySeconds: 15
      periodSeconds: 5
      scheme: HTTP
      timeoutSeconds: 30
    replicas: 1
    resources: {}
    securityContext: {}
    service:
      annotations: {}
      loadBalancerSourceRanges: []
      ports:
      - name: airflow-ui
        port: '{{ .Values.ports.airflowUI }}'
      type: ClusterIP
    serviceAccount:
      annotations: {}
      create: true
    tolerations: []
    topologySpreadConstraints: []
    waitForMigrations:
      enabled: true
      env: []
  workers:
    affinity: {}
    args:
    - bash
    - -c
    - |-
      exec \
      airflow {{ semverCompare ">=2.0.0" .Values.airflowVersion | ternary "celery worker" "worker" }}
    env: []
    extraContainers: []
    extraInitContainers: []
    extraVolumeMounts: []
    extraVolumes: []
    hostAliases: []
    keda:
      advanced: {}
      cooldownPeriod: 30
      enabled: false
      maxReplicaCount: 10
      minReplicaCount: 0
      namespaceLabels: {}
      pollingInterval: 5
    kerberosSidecar:
      enabled: false
      resources: {}
    labels: {}
    livenessProbe:
      enabled: true
      failureThreshold: 5
      initialDelaySeconds: 10
      periodSeconds: 60
      timeoutSeconds: 20
    logGroomerSidecar:
      args:
      - bash
      - /clean-logs
      resources: {}
      retentionDays: 15
    nodeSelector: {}
    persistence:
      annotations: {}
      enabled: true
      fixPermissions: false
      size: 50Gi
    podAnnotations: {}
    replicas: 1
    resources: {}
    safeToEvict: true
    securityContext: {}
    serviceAccount:
      annotations: {}
      create: true
    strategy:
      rollingUpdate:
        maxSurge: 100%
        maxUnavailable: 50%
    terminationGracePeriodSeconds: 600
    tolerations: []
    topologySpreadConstraints: []
    waitForMigrations:
      env: []
autoscaling:
  enabled: false
  maxReplicas: 100
  minReplicas: 1
  targetCPUUtilizationPercentage: 80
fluentbit:
  fluentdHost: fluentd.default
  fluentdPort: 24224
fullnameOverride: ""
hiveConnector: true
image:
  pullPolicy: IfNotPresent
  repository: nginx
  tag: ""
imagePullSecrets: []
ingress:
  annotations: {}
  className: ""
  enabled: false
  hosts:
  - host: chart-example.local
    paths:
    - path: /
      pathType: ImplementationSpecific
  tls: []
minio:
  DeploymentUpdate:
    maxSurge: 100%
    maxUnavailable: 0
    type: RollingUpdate
  StatefulSetUpdate:
    updateStrategy: RollingUpdate
  additionalAnnotations: {}
  additionalLabels: {}
  affinity: {}
  bucketRoot: ""
  certsPath: /etc/minio/certs/
  clusterDomain: cluster.local
  configPathmc: /etc/minio/mc/
  consoleIngress:
    annotations: {}
    enabled: false
    hosts:
    - console.minio-example.local
    labels: {}
    path: /
    tls: []
  consoleService:
    nodePort: 30001
    port: "9001"
    type: NodePort
  customCommandJob:
    affinity: {}
    annotations: {}
    exitCommand: ""
    nodeSelector: {}
    podAnnotations: {}
    resources:
      requests:
        memory: 128Mi
    securityContext:
      enabled: false
      fsGroup: 1000
      runAsGroup: 1000
      runAsUser: 1000
    tolerations: []
  drivesPerNode: 1
  enabled: true
  etcd:
    clientCert: ""
    clientCertKey: ""
    corednsPathPrefix: ""
    endpoints: []
    pathPrefix: ""
  existingSecret: ""
  extraArgs: []
  extraContainers: []
  extraVolumeMounts: []
  extraVolumes: []
  fullnameOverride: ""
  global: {}
  ignoreChartChecksums: false
  image:
    pullPolicy: IfNotPresent
    repository: quay.io/minio/minio
    tag: RELEASE.2022-11-11T03-44-20Z
  imagePullSecrets: []
  ingress:
    annotations: {}
    enabled: false
    hosts:
    - minio-example.local
    labels: {}
    path: /
    tls: []
  makeBucketJob:
    affinity: {}
    annotations: {}
    exitCommand: ""
    extraVolumeMounts: []
    extraVolumes: []
    nodeSelector: {}
    podAnnotations: {}
    resources:
      requests:
        memory: 128Mi
    securityContext:
      enabled: false
      fsGroup: 1000
      runAsGroup: 1000
      runAsUser: 1000
    tolerations: []
  makePolicyJob:
    affinity: {}
    annotations: {}
    exitCommand: ""
    extraVolumeMounts: []
    extraVolumes: []
    nodeSelector: {}
    podAnnotations: {}
    resources:
      requests:
        memory: 128Mi
    securityContext:
      enabled: false
      fsGroup: 1000
      runAsGroup: 1000
      runAsUser: 1000
    tolerations: []
  makeServiceAccountJob:
    affinity: {}
    annotations: {}
    exitCommand: ""
    extraVolumeMounts: []
    extraVolumes: []
    nodeSelector: {}
    podAnnotations: {}
    resources:
      requests:
        memory: 128Mi
    securityContext:
      enabled: false
      fsGroup: 1000
      runAsGroup: 1000
      runAsUser: 1000
    tolerations: []
  makeUserJob:
    affinity: {}
    annotations: {}
    exitCommand: ""
    extraVolumeMounts: []
    extraVolumes: []
    nodeSelector: {}
    podAnnotations: {}
    resources:
      requests:
        memory: 128Mi
    securityContext:
      enabled: false
      fsGroup: 1000
      runAsGroup: 1000
      runAsUser: 1000
    tolerations: []
  mcImage:
    pullPolicy: IfNotPresent
    repository: quay.io/minio/mc
    tag: RELEASE.2022-11-07T23-47-39Z
  metrics:
    serviceMonitor:
      additionalLabels: {}
      enabled: false
      includeNode: false
      public: true
      relabelConfigs: {}
      relabelConfigsCluster: {}
  minioAPIPort: "9000"
  minioConsolePort: "9001"
  mode: distributed
  mountPath: /export
  nameOverride: ""
  networkPolicy:
    allowExternal: true
    enabled: false
  nodeSelector: {}
  oidc:
    claimName: policy
    claimPrefix: ""
    clientId: minio
    clientSecret: ""
    comment: ""
    configUrl: https://identity-provider-url/.well-known/openid-configuration
    enabled: false
    redirectUri: https://console-endpoint-url/oauth_callback
    scopes: openid,profile,email
  persistence:
    VolumeName: ""
    accessMode: ReadWriteOnce
    annotations: {}
    enabled: true
    existingClaim: ""
    size: 500Mi
    storageClass: ""
    subPath: ""
  podAnnotations: {}
  podDisruptionBudget:
    enabled: false
    maxUnavailable: 1
  podLabels: {}
  policies: []
  pools: 1
  priorityClassName: ""
  replicas: 3
  resources:
    requests:
      memory: 500Mi
  rootPassword: adminpassword
  rootUser: admin
  runtimeClassName: ""
  securityContext:
    enabled: true
    fsGroup: 1000
    fsGroupChangePolicy: OnRootMismatch
    runAsGroup: 1000
    runAsUser: 1000
  service:
    nodePort: 32000
    port: "9000"
    type: ClusterIP
  serviceAccount:
    create: true
    name: minio-sa
  tls:
    certSecret: ""
    enabled: false
    privateKey: private.key
    publicCrt: public.crt
  tolerations: []
  topologySpreadConstraints: []
  trustedCertsSecret: ""
  users:
  - accessKey: console
    policy: consoleAdmin
    secretKey: console123
nameOverride: ""
nodeSelector: {}
pg:
  access:
    database: gps_data
    password: gpspassword
    port: 5432
    user: gpsuser
  affinity: {}
  autoscaling:
    enabled: false
    maxReplicas: 100
    minReplicas: 1
    targetCPUUtilizationPercentage: 80
  component: bd
  containerport: 5432
  enabled: false
  fullnameOverride: ""
  global: {}
  image:
    pullPolicy: IfNotPresent
    repository: postgres:14-alpine
    tag: ""
  imagePullSecrets: []
  ingress:
    annotations: {}
    className: ""
    enabled: false
    hosts:
    - host: chart-example.local
      paths:
      - path: /
        pathType: ImplementationSpecific
    tls: []
  nameOverride: ""
  nodeSelector: {}
  persistence:
    accesmodes: ReadWriteOnce
    bindingmode: Immediate
    enabled: true
    reclaimpolicy: Delete
    storageallocation: 500Mi
  podAnnotations: {}
  podSecurityContext: {}
  replicaCount: 3
  resources: {}
  securityContext: {}
  service:
    port: 5432
    type: NodePort
  serviceAccount:
    annotations: {}
    create: true
    name: ""
  tolerations: []
podAnnotations: {}
podSecurityContext: {}
replicaCount: 1
resources: {}
securityContext: {}
service:
  port: 80
  type: ClusterIP
serviceAccount:
  annotations: {}
  create: true
  name: ""
tolerations: []
trino:
  Hive:
    Postgres354:
      access:
        database: test
        password: test
        port: 5432
        user: test
      affinity: {}
      autoscaling:
        enabled: false
        maxReplicas: 100
        minReplicas: 1
        targetCPUUtilizationPercentage: 80
      component: bd
      containerport: 5432
      fullnameOverride: ""
      global: {}
      image:
        pullPolicy: IfNotPresent
        repository: postgres:14-alpine
        tag: ""
      imagePullSecrets: []
      ingress:
        annotations: {}
        className: ""
        enabled: false
        hosts:
        - host: chart-example.local
          paths:
          - path: /
            pathType: ImplementationSpecific
        tls: []
      nameOverride: ""
      nodeSelector: {}
      persistence:
        accesmodes: ReadWriteOnce
        bindingmode: Immediate
        enabled: true
        reclaimpolicy: Delete
        storageallocation: 100Mi
      podAnnotations: {}
      podSecurityContext: {}
      replicaCount: 1
      resources: {}
      securityContext: {}
      service:
        port: 5432
        type: ClusterIP
      serviceAccount:
        annotations: {}
        create: true
        name: ""
      tolerations: []
    affinity: {}
    autoscaling:
      enabled: false
      maxReplicas: 100
      minReplicas: 1
      targetCPUUtilizationPercentage: 80
    binDirectory: /opt/apache-hive-metastore-3.0.0-bin
    fullnameOverride: ""
    global: {}
    hadoopDirectory: /opt/hadoop-3.2.0
    image:
      pullPolicy: IfNotPresent
      repository: team354/hivemetastore
    imagePullSecrets: []
    ingress:
      annotations: {}
      className: ""
      enabled: false
      hosts:
      - host: chart-example.local
        paths:
        - path: /
          pathType: ImplementationSpecific
      tls: []
    nameOverride: ""
    nodeSelector: {}
    pg:
      access:
        database: metadata
        password: hivepassword
        port: 5432
        user: hive
      affinity: {}
      autoscaling:
        enabled: false
        maxReplicas: 100
        minReplicas: 1
        targetCPUUtilizationPercentage: 80
      component: metastore
      containerport: 5432
      fullnameOverride: ""
      global: {}
      image:
        pullPolicy: IfNotPresent
        repository: postgres:14-alpine
        tag: ""
      imagePullSecrets: []
      ingress:
        annotations: {}
        className: ""
        enabled: false
        hosts:
        - host: chart-example.local
          paths:
          - path: /
            pathType: ImplementationSpecific
        tls: []
      nameOverride: ""
      nodeSelector: {}
      persistence:
        accesmodes: ReadWriteOnce
        bindingmode: Immediate
        class: null
        enabled: true
        reclaimpolicy: Delete
        storageallocation: 100Mi
      podAnnotations: {}
      podSecurityContext: {}
      replicaCount: 1
      resources: {}
      securityContext: {}
      service:
        port: 5432
        type: ClusterIP
      serviceAccount:
        annotations: {}
        create: true
        name: ""
      tolerations: []
    podAnnotations: {}
    podSecurityContext: {}
    replicaCount: 1
    resources: {}
    s3:
      coreSite:
        connectionSslEnabled: false
        defaultFS: ""
        endpoint: ""
        pathStyleAccess: true
        xmlContent: ""
      enabled: true
      internal: true
      metastore:
        ConnectionPassword: hivepassword
        ConnectionUserName: hive
        database: metadata
        port: 5432
      rootPassword: adminpassword
      rootUser: admin
    securityContext: {}
    service:
      port: 80
      type: ClusterIP
    serviceAccount:
      annotations: {}
      create: true
      name: ""
    tolerations: []
  HiveMetastore:
    Postgres354:
      access:
        database: test
        password: test
        port: 5432
        user: test
      affinity: {}
      autoscaling:
        enabled: false
        maxReplicas: 100
        minReplicas: 1
        targetCPUUtilizationPercentage: 80
      component: bd
      containerport: 5432
      fullnameOverride: ""
      global: {}
      image:
        pullPolicy: IfNotPresent
        repository: postgres:14-alpine
        tag: ""
      imagePullSecrets: []
      ingress:
        annotations: {}
        className: ""
        enabled: false
        hosts:
        - host: chart-example.local
          paths:
          - path: /
            pathType: ImplementationSpecific
        tls: []
      nameOverride: ""
      nodeSelector: {}
      persistence:
        accesmodes: ReadWriteOnce
        bindingmode: Immediate
        enabled: true
        reclaimpolicy: Delete
        storageallocation: 100Mi
      podAnnotations: {}
      podSecurityContext: {}
      replicaCount: 1
      resources: {}
      securityContext: {}
      service:
        port: 5432
        type: ClusterIP
      serviceAccount:
        annotations: {}
        create: true
        name: ""
      tolerations: []
    affinity: {}
    autoscaling:
      enabled: false
      maxReplicas: 100
      minReplicas: 1
      targetCPUUtilizationPercentage: 80
    binDirectory: /opt/apache-hive-metastore-3.0.0-bin
    fullnameOverride: ""
    global: {}
    hadoopDirectory: /opt/hadoop-3.2.0
    image:
      pullPolicy: IfNotPresent
      repository: team354/hivemetastore
    imagePullSecrets: []
    ingress:
      annotations: {}
      className: ""
      enabled: false
      hosts:
      - host: chart-example.local
        paths:
        - path: /
          pathType: ImplementationSpecific
      tls: []
    nameOverride: ""
    nodeSelector: {}
    pg:
      access:
        database: metadata
        password: hivepassword
        port: 5432
        user: hive
      affinity: {}
      autoscaling:
        enabled: false
        maxReplicas: 100
        minReplicas: 1
        targetCPUUtilizationPercentage: 80
      component: metastore
      containerport: 5432
      fullnameOverride: ""
      global: {}
      image:
        pullPolicy: IfNotPresent
        repository: postgres:14-alpine
        tag: ""
      imagePullSecrets: []
      ingress:
        annotations: {}
        className: ""
        enabled: false
        hosts:
        - host: chart-example.local
          paths:
          - path: /
            pathType: ImplementationSpecific
        tls: []
      nameOverride: ""
      nodeSelector: {}
      persistence:
        accesmodes: ReadWriteOnce
        bindingmode: Immediate
        enabled: true
        reclaimpolicy: Delete
        storageallocation: 100Mi
      podAnnotations: {}
      podSecurityContext: {}
      replicaCount: 1
      resources: {}
      securityContext: {}
      service:
        port: 5432
        type: ClusterIP
      serviceAccount:
        annotations: {}
        create: true
        name: ""
      tolerations: []
    podAnnotations: {}
    podSecurityContext: {}
    replicaCount: 1
    resources: {}
    s3:
      coreSite:
        connectionSslEnabled: false
        defaultFS: ""
        endpoint: ""
        pathStyleAccess: true
        xmlContent: ""
      enabled: true
      internal: true
      metastore:
        ConnectionPassword: hivepassword
        ConnectionUserName: hive
        database: metadata
        port: 5432
      rootPassword: root
      rootUser: root
    securityContext: {}
    service:
      port: 80
      type: ClusterIP
    serviceAccount:
      annotations: {}
      create: true
      name: ""
    tolerations: []
  affinity: {}
  autoscaling:
    enabled: false
    maxReplicas: 100
    minReplicas: 1
    targetCPUUtilizationPercentage: 80
  coordinateur:
    replicas: 1
    resources:
      limits:
        cpu: 1000m
        memory: 2Gi
      requests:
        cpu: 1000m
        memory: 2Gi
  enabled: false
  fullnameOverride: ""
  global: {}
  hiveConnector: true
  image:
    repository: trinodb/trino:355
    tag: ""
  imagePullSecrets: []
  ingress:
    annotations: {}
    className: ""
    enabled: false
    hosts:
    - host: chart-example.local
      paths:
      - path: /
        pathType: ImplementationSpecific
    tls: []
  nameOverride: ""
  nodeSelector: {}
  podAnnotations: {}
  podSecurityContext: {}
  replicaCount: 1
  resources: {}
  s3:
    datalakeProperties: ""
    endpoint: ""
  securityContext: {}
  service:
    nodeport: 30002
    port: 8080
    type: NodePort
  serviceAccount:
    annotations: {}
    create: true
    name: ""
  tolerations: []
  workers:
    replicas: 2
    resources:
      limits:
        cpu: 1000m
        memory: 2Gi
      requests:
        cpu: 1000m
        memory: 2Gi
    storage: 2Gi
